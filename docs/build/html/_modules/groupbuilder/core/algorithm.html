

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>groupbuilder.core.algorithm &mdash; Student Grouper 1 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="../../../_static/css/theme.css?v=e59714d7" />

  
      <script src="../../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../../_static/documentation_options.js?v=29a6c3e3"></script>
      <script src="../../../_static/doctools.js?v=9bcbadda"></script>
      <script src="../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../../index.html" class="icon icon-home">
            Student Grouper
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../modules.html">wxpython-grouping</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">Student Grouper</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../../index.html">Module code</a></li>
      <li class="breadcrumb-item active">groupbuilder.core.algorithm</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for groupbuilder.core.algorithm</h1><div class="highlight"><pre>
<span></span><span class="kn">import</span><span class="w"> </span><span class="nn">itertools</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">math</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">functools</span><span class="w"> </span><span class="kn">import</span> <span class="n">reduce</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">operator</span><span class="w"> </span><span class="kn">import</span> <span class="n">or_</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">typing_extensions</span><span class="w"> </span><span class="kn">import</span> <span class="n">deprecated</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">.data_models</span><span class="w"> </span><span class="kn">import</span> <span class="n">GroupConfig</span>

<div class="viewcode-block" id="GroupingAlgorithm">
<a class="viewcode-back" href="../../../groupbuilder.core.html#groupbuilder.core.algorithm.GroupingAlgorithm">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">GroupingAlgorithm</span><span class="p">:</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">config</span><span class="p">:</span> <span class="n">GroupConfig</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_amount_people</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">amount_people</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_group_size</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">group_size</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">__unique_rounds</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">__groups_per_round</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__get_groups_per_round</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">__all_combinations</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__generate_all_possible_combs</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_current_round_ind</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_max_rounds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_max_possibilities</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_rounds</span> <span class="o">=</span> <span class="p">{}</span>


    <span class="k">def</span><span class="w"> </span><span class="nf">__get_groups_per_round</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="n">remainder</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_amount_people</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">_group_size</span>
        <span class="k">if</span> <span class="n">remainder</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_amount_people</span> <span class="o">+</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_group_size</span> <span class="o">-</span> <span class="n">remainder</span><span class="p">))</span> <span class="o">//</span> <span class="bp">self</span><span class="o">.</span><span class="n">_group_size</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_amount_people</span> <span class="o">//</span> <span class="bp">self</span><span class="o">.</span><span class="n">_group_size</span>


    <span class="k">def</span><span class="w"> </span><span class="nf">__generate_all_possible_combs</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">set</span><span class="p">:</span>
        <span class="n">people</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_amount_people</span><span class="p">))</span>

        <span class="c1"># Add placeholders (-1) for missing people to make total divisible by group size</span>
        <span class="n">total_people</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_amount_people</span>
        <span class="k">while</span> <span class="n">total_people</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">_group_size</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">people</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">total_people</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="n">all_combinations_list</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">itertools</span><span class="o">.</span><span class="n">combinations</span><span class="p">(</span><span class="n">people</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_group_size</span><span class="p">))</span>
        <span class="n">all_combs_set</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">comb</span> <span class="ow">in</span> <span class="n">all_combinations_list</span><span class="p">:</span>
            <span class="n">comb_set</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">comb</span><span class="p">)</span>
            <span class="k">if</span> <span class="o">-</span><span class="mi">1</span> <span class="ow">in</span> <span class="n">comb_set</span><span class="p">:</span>
                <span class="n">comb_set</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">all_combs_set</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="nb">frozenset</span><span class="p">(</span><span class="n">comb_set</span><span class="p">))</span>
        <span class="c1"># print(len(all_combs_set) // self.__groups_per_round)</span>
        <span class="k">return</span> <span class="n">all_combs_set</span>

<div class="viewcode-block" id="GroupingAlgorithm.get_round">
<a class="viewcode-back" href="../../../groupbuilder.core.html#groupbuilder.core.algorithm.GroupingAlgorithm.get_round">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_round</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rounds</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_current_round_ind</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span></div>


<div class="viewcode-block" id="GroupingAlgorithm.generate_next_round">
<a class="viewcode-back" href="../../../groupbuilder.core.html#groupbuilder.core.algorithm.GroupingAlgorithm.generate_next_round">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">generate_next_round</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the number of possible unique Round combinations.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__all_combinations</span> <span class="o">==</span> <span class="nb">set</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">StopIteration</span><span class="p">(</span><span class="s2">&quot;No more rounds can be generated.&quot;</span><span class="p">)</span>

        <span class="n">combs_iter</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__all_combinations</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">bitmask_cache</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">group_comb</span> <span class="ow">in</span> <span class="n">combs_iter</span><span class="p">:</span>
                <span class="n">combs_working</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__all_combinations</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                <span class="n">current_groups</span> <span class="o">=</span> <span class="p">[</span><span class="n">group_comb</span><span class="p">]</span>
                <span class="n">combs_working</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">group_comb</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">group_comb</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">bitmask_cache</span><span class="p">:</span>
                    <span class="n">bitmask_cache</span><span class="p">[</span><span class="n">group_comb</span><span class="p">]</span> <span class="o">=</span> <span class="n">reduce</span><span class="p">(</span><span class="n">or_</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">group_comb</span><span class="p">),</span> <span class="mi">0</span><span class="p">)</span>
                <span class="k">break</span>
            <span class="n">new_group</span><span class="p">,</span> <span class="n">new_working_set</span><span class="p">,</span> <span class="n">outcast</span><span class="p">,</span> <span class="n">not_found</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__add_next_group</span><span class="p">(</span><span class="n">current_groups</span><span class="p">,</span> <span class="n">combs_working</span><span class="p">,</span> <span class="p">[],</span> <span class="mi">2</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">__groups_per_round</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="n">bitmask_cache</span><span class="p">)</span>

            <span class="n">new_working_set</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">outcast</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">not_found</span><span class="p">:</span>
                <span class="k">break</span>

            <span class="k">try</span><span class="p">:</span>
                <span class="n">combs_iter</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">group_comb</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">StopIteration</span><span class="p">(</span><span class="s2">&quot;No more rounds can be generated.&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__all_combinations</span> <span class="o">=</span> <span class="n">new_working_set</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_rounds</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_current_round_ind</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_group</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_current_round_ind</span> <span class="o">+=</span> <span class="mi">1</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">__add_next_group</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">old_group</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">frozenset</span><span class="p">],</span> <span class="n">old_working_set</span><span class="p">:</span> <span class="nb">set</span><span class="p">[</span><span class="nb">frozenset</span><span class="p">],</span> <span class="n">outcast</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">frozenset</span><span class="p">],</span>
                         <span class="n">self_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">max_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">not_found</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span> <span class="n">bitmask_cache</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">frozenset</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span>
        <span class="nb">list</span><span class="p">[</span><span class="nb">frozenset</span><span class="p">],</span> <span class="nb">set</span><span class="p">[</span><span class="nb">frozenset</span><span class="p">],</span> <span class="nb">list</span><span class="p">[</span><span class="nb">frozenset</span><span class="p">],</span> <span class="nb">bool</span><span class="p">]:</span>

        <span class="c1"># Initialize bitmask cache if not provided</span>
        <span class="k">if</span> <span class="n">bitmask_cache</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">bitmask_cache</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="c1"># Use in-place modifications</span>
        <span class="n">working_set</span> <span class="o">=</span> <span class="n">old_working_set</span>
        <span class="n">working_group</span> <span class="o">=</span> <span class="n">old_group</span>


        <span class="k">while</span> <span class="n">working_set</span><span class="p">:</span>
            <span class="n">group_comb</span> <span class="o">=</span> <span class="n">working_set</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>  <span class="c1"># Efficient O(1) removal instead of iteration</span>

            <span class="c1"># Get or compute bitmask for the current group_comb</span>
            <span class="k">if</span> <span class="n">group_comb</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">bitmask_cache</span><span class="p">:</span>
                <span class="n">bitmask_cache</span><span class="p">[</span><span class="n">group_comb</span><span class="p">]</span> <span class="o">=</span> <span class="n">reduce</span><span class="p">(</span><span class="n">or_</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">group_comb</span><span class="p">),</span> <span class="mi">0</span><span class="p">)</span>
            <span class="n">groupmask</span> <span class="o">=</span> <span class="n">bitmask_cache</span><span class="p">[</span><span class="n">group_comb</span><span class="p">]</span>

            <span class="c1"># Check for intersection using cached bitmasks</span>
            <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">groupmask</span> <span class="o">&amp;</span> <span class="n">bitmask_cache</span><span class="p">[</span><span class="n">comb</span><span class="p">]</span> <span class="k">for</span> <span class="n">comb</span> <span class="ow">in</span> <span class="n">working_group</span><span class="p">):</span>
                <span class="n">outcast</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">group_comb</span><span class="p">)</span>
                <span class="k">continue</span>  <span class="c1"># Skip invalid groups</span>

            <span class="c1"># Add to group and update precomputed bitmasks</span>
            <span class="n">working_group</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">group_comb</span><span class="p">)</span>
            <span class="n">bitmask_cache</span><span class="p">[</span><span class="n">group_comb</span><span class="p">]</span> <span class="o">=</span> <span class="n">groupmask</span>
            <span class="k">break</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">StopIteration</span><span class="p">(</span><span class="s2">&quot;No more rounds can be generated.&quot;</span><span class="p">)</span>

        <span class="c1"># Recursive case</span>
        <span class="k">if</span> <span class="n">self_id</span> <span class="o">!=</span> <span class="n">max_id</span><span class="p">:</span>
            <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">new_group</span><span class="p">,</span> <span class="n">new_working_set</span><span class="p">,</span> <span class="n">outcast</span><span class="p">,</span> <span class="n">not_found</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__add_next_group</span><span class="p">(</span>
                        <span class="n">working_group</span><span class="p">,</span> <span class="n">working_set</span><span class="p">,</span> <span class="n">outcast</span><span class="p">,</span> <span class="n">self_id</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">max_id</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="n">bitmask_cache</span>
                    <span class="p">)</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">not_found</span><span class="p">:</span>
                        <span class="k">return</span> <span class="n">new_group</span><span class="p">,</span> <span class="n">new_working_set</span><span class="p">,</span> <span class="n">outcast</span><span class="p">,</span> <span class="kc">False</span>
                <span class="k">except</span> <span class="ne">StopIteration</span><span class="p">:</span>
                    <span class="n">removed_group</span> <span class="o">=</span> <span class="n">working_group</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
                    <span class="n">outcast</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">removed_group</span><span class="p">)</span>
                    <span class="n">bitmask_cache</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">removed_group</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>  <span class="c1"># Remove from cache</span>
                    <span class="k">return</span> <span class="n">old_group</span><span class="p">,</span> <span class="n">working_set</span><span class="p">,</span> <span class="n">outcast</span><span class="p">,</span> <span class="kc">True</span>

                <span class="n">working_group</span><span class="p">,</span> <span class="n">working_set</span><span class="p">,</span> <span class="n">outcast</span> <span class="o">=</span> <span class="n">new_group</span><span class="p">,</span> <span class="n">new_working_set</span><span class="p">,</span> <span class="n">outcast</span>

        <span class="k">return</span> <span class="n">working_group</span><span class="p">,</span> <span class="n">working_set</span><span class="p">,</span> <span class="n">outcast</span><span class="p">,</span> <span class="kc">False</span>



<div class="viewcode-block" id="GroupingAlgorithm.get_remaining_rounds">
<a class="viewcode-back" href="../../../groupbuilder.core.html#groupbuilder.core.algorithm.GroupingAlgorithm.get_remaining_rounds">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_remaining_rounds</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_max_rounds</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">_current_round_ind</span></div>


<div class="viewcode-block" id="GroupingAlgorithm.get_max_rounds">
<a class="viewcode-back" href="../../../groupbuilder.core.html#groupbuilder.core.algorithm.GroupingAlgorithm.get_max_rounds">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_max_rounds</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_max_rounds</span></div>


<div class="viewcode-block" id="GroupingAlgorithm._get_max_possibilities">
<a class="viewcode-back" href="../../../groupbuilder.core.html#groupbuilder.core.algorithm.GroupingAlgorithm._get_max_possibilities">[docs]</a>
    <span class="nd">@deprecated</span><span class="p">(</span><span class="s2">&quot;This calculation is not accurate anymore.&quot;</span><span class="p">)</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_get_max_possibilities</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">.. note::</span>
<span class="sd">  Method is deprecated, because it is not accurate anymore, the cause for this is that it does not take into account that the algorithm is not allowed to generate the same group twice.</span>

<span class="sd">Calculate an upper bound on the number of rounds possible.</span>

<span class="sd">This method computes an approximate maximum number of rounds that can be generated based on the total number of unique groups</span>
<span class="sd">that can be formed and the number of groups per round. The calculation involves adjusting the number of people to ensure that</span>
<span class="sd">it is divisible by the group size by adding placeholders if necessary.</span>

<span class="sd">Given</span>
<span class="sd">~~~~~</span>
<span class="sd">- :math:`P`: Total number of people.</span>
<span class="sd">- :math:`G`: Group size.</span>
<span class="sd">- :math:`\\text{remainder}`: Number of placeholders (added if :math:`P` is not divisible by :math:`G`).</span>
<span class="sd">- :math:`P_{adjusted}`: Total number of participants (including placeholders).</span>
<span class="sd">- :math:`R`: The number of groups formed in a round.</span>
<span class="sd">- :math:`\\text{total_groups}`: The product of binomial coefficients for each group.</span>

<span class="sd">Formula Steps</span>
<span class="sd">~~~~~~~~~~~~~</span>
<span class="sd">1. **Adjustment of the Number of People**</span>

<span class="sd">  - Calculate the remainder when the number of people is divided by the group size:</span>
<span class="sd">      .. math::</span>
<span class="sd">        \\text{remainder} = P \\mod G</span>
<span class="sd">  - If the remainder is not zero, increase the number of people by the missing value to allow even group division:</span>
<span class="sd">      .. math::</span>
<span class="sd">        P_{adjusted} = P + (G - \\text{remainder}) \\quad \\text{if } \\text{remainder} \\neq 0</span>
<span class="sd">    If there is no remainder, the number of people remains unchanged:</span>
<span class="sd">      .. math::</span>
<span class="sd">        P_{adjusted} = P</span>

<span class="sd">2. **Calculation of Groups per Round**</span>

<span class="sd">  - The number of groups per round is given by:</span>
<span class="sd">      .. math::</span>
<span class="sd">        R = \\frac{P_{adjusted}}{G}</span>

<span class="sd">3. **Total Number of Unique Groups (Combinations)**</span>

<span class="sd">  - The number of possible unique groups is given by the binomial coefficient:</span>
<span class="sd">      .. math::</span>
<span class="sd">        \\text{total_groups} = \\binom{P_{adjusted}}{G}</span>

<span class="sd">4. **Maximum Number of Rounds**</span>

<span class="sd">  - The upper bound for the number of rounds is given by:</span>
<span class="sd">      .. math::</span>
<span class="sd">        \\text{max_rounds} = \\frac{\\text{total_groups}}{R}</span>

<span class="sd">This formula calculates the total number of unique round combinations based on the number of participants and the group size, taking into account any necessary placeholders.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Adjust the number of people to include placeholders if needed.</span>
        <span class="n">P</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_amount_people</span>
        <span class="n">G</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_group_size</span>

        <span class="n">remainder</span> <span class="o">=</span> <span class="n">P</span> <span class="o">%</span> <span class="n">G</span>
        <span class="k">if</span> <span class="n">remainder</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">P_adjusted</span> <span class="o">=</span> <span class="n">P</span> <span class="o">+</span> <span class="p">(</span><span class="n">G</span> <span class="o">-</span> <span class="n">remainder</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">P_adjusted</span> <span class="o">=</span> <span class="n">P</span>

        <span class="c1"># Calculate groups per round (R)</span>
        <span class="n">R</span> <span class="o">=</span> <span class="n">P_adjusted</span> <span class="o">//</span> <span class="n">G</span>

        <span class="c1"># Total number of unique groups (combinations)</span>
        <span class="n">total_groups</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">comb</span><span class="p">(</span><span class="n">P_adjusted</span><span class="p">,</span> <span class="n">G</span><span class="p">)</span>

        <span class="c1"># Upper bound on the number of rounds</span>
        <span class="n">max_rounds</span> <span class="o">=</span> <span class="n">total_groups</span> <span class="o">//</span> <span class="n">R</span>
        <span class="k">return</span> <span class="n">max_rounds</span></div>
</div>

</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2025, DerVogel101.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>